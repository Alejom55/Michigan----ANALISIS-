<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inicio</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat+Alternates&family=Orbitron:wght@800&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/3ab1775d52.js" crossorigin="anonymous"></script>
</head>
<style>
  .buttonx {
 position: relative;
 height: 50px;
 width: 100px;
 border: 2px solid #ffffff;
 background: #000000;
 user-select: none;
 white-space: nowrap;
 transition: all .05s linear;
 font-family: inherit;
 color: #F3FFF9;
}

.buttonx:before, .buttonx:after {
 content: "";
 position: absolute;
 background: #011522;
 transition: all .2s linear;
}

.buttonx:before {
 width: calc(100% + 6px);
 height: calc(100% - 16px);
 top: 8px;
 left: -3px;
}

.buttonx:after {
 width: calc(100% - 16px);
 height: calc(100% + 6px);
 top: -3px;
 left: 8px;
}

.buttonx:hover {
 cursor: crosshair;
}

.buttonx:active {
 transform: scale(0.95);
}

.buttonx:hover:before {
 height: calc(100% - 32px);
 top: 16px;
}

.buttonx:hover:after {
 width: calc(100% - 32px);
 left: 16px;
}

.buttonx span {
 font-size: 15px;
 z-index: 3;
 position: relative;
 font-weight: 600;
}
  .textarea {
 width: 500px;
 height: 254px;
 background: white;
 border-radius: 10px;
 transition: border-radius 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.shadow {
 box-shadow: inset 0 -3em 3em rgb(255, 0, 0),
             0 0  0 2px rgb(255, 0, 0),
             0.3em 0.3em 1em rgb(255, 0, 0);
}


  .input__container--variant {
  background: linear-gradient(to bottom, #F3FFF9, #F3FFF9);
  border-radius: 30px;
  width: 500px;


}

.shadow__input--variant {
  filter: blur(25px);
  border-radius: 30px;
  background-color: #F3FFF9;
  opacity: 0.5;
}

.input__button__shadow--variant {
  border-radius: 15px;
  background-color: #07372C;
  padding: 10px;
  border: none;
  width: 460px;
}

.input__button__shadow--variant:hover {
  background-color: #3C6659;
}

.input__search--variant {
  width: 470px;
  align-items: center;
  border-radius: 13em;
  outline: none;
  border: none;
  padding: 0.8em;
  font-size: 1.2em;
  color: #002019;
  background-color: transparent;
}

.input__search--variant::placeholder {
  color: #002019;
  opacity: 0.7;
}

.input__container--variant {
  background: linear-gradient(to bottom, #F3FFF9, #F3FFF9);
  border-radius: 1.5em;
  padding: 1em;
  box-shadow: 0em 1em 3em #beecdc64;
}


    /* Center the content in the card */
    .card__content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

.card {
 width: 100%;
 height: 1000px;
 margin: 0 auto;
 background-color: #011522;
 z-index: 1;
}

.tools {
 display: flex;
 align-items: center;
 padding: 9px;
}

.circle {
 padding: 0 4px;
}

.box {
 display: inline-block;
 align-items: center;
 width: 10px;
 height: 10px;
 padding: 1px;
 border-radius: 50%;
}

.red {
 background-color: #ff605c;
}

.yellow {
 background-color: #ffbd44;
}

.green {
 background-color: #00ca4e;
}


</style>

<body>
  <div class="card">
    <div class="tools">
      <div class="circle">
        <span class="red box"></span>
      </div>
      <div class="circle">
        <span class="yellow box"></span>
      </div>
      <div class="circle">
        <span class="green box"></span>
      </div>
    </div>

    <div class="card__content">
      <div class="col-sm-4" style="margin-top: 100px; margin-left: 200px;">
        <h1 for="" style="color: azure;font-family: 'Orbitron', sans-serif;">Inserte su Endpoint</h1><br>
        <div class="input__container input__container--variant mt-4">
          <div class="shadow__input shadow__input--variant"></div>
          <input type="text" name="text" id="inputend" class="input__search input__search--variant" placeholder="Search...">
          <button class="input__button__shadow input__button__shadow--variant" id="endpoint">
            <svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" height="1.5em" width="13em">
              <path d="M4 9a5 5 0 1110 0A5 5 0 014 9zm5-7a7 7 0 104.2 12.6.999.999 0 00.093.107l3 3a1 1 0 001.414-1.414l-3-3a.999.999 0 00-.107-.093A7 7 0 009 2z" fill-rule="evenodd" fill="#FFF"></path>
            </svg>
          </button>
        </div>
      </div><br>

      <div class="col-sm-3" style="margin-left: 50px;">
        <select class="form-control" id="mi-select" style="display: none;background-color: #F3FFF9;">
          <br>
          <textarea class="mt-3 textarea shadow" id="textarea" cols="30" rows="10" style="display: none;"></textarea>

        </select>
        <div class="row px-2">
          <select class="form-control" id="sort" style="display: none;background-color: #F3FFF9; width: 200px;margin-left: 5px;">
            <option value="1">Bubblesort</option>
            <option value="2">Quicksort</option>
            <option value="3">Mergesort</option>
            <option value="4">Radixsort</option>
            <option value="5">Heapsort</option>
            <option value="6">Countsort</option>
          </select>
          <button id="calculo" class="buttonx" style="display: none; width: 100px;margin-left: 20px;"><span>Calcular</span></button>
        </div>
        <div class="row mt-4">
          <label id="timelabel" for="time" style="font-family: 'Orbitron', sans-serif;display: none;color: azure;">Tiempo de Ejecución</label>
          <textarea class="mt-3 form-control" id="time" cols="10" rows="1" style="display: none;background-color: #F3FFF9;margin-left: 5px;" placeholder="Tiempo de ejecución"></textarea>
        </div>
      </div>
     //Es importante tener en cuenta que la notación Big O se utiliza principalmente para analizar algoritmos y estructuras de datos en función del crecimiento de los datos de entrada. No se aplica directamente a operaciones de carga de recursos externos o estilos CSS, por eso no vamos a poner ninguna notacion es esas lineas anteriores  de codigo.

    </div>

  </div>

  <!-- Importa los scripts de Bootstrap -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script> <!-- O(1) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script> <!-- O(1) -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script> <!-- O(1) -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.18/dist/sweetalert2.all.min.js"></script> <!-- O(1) -->
  <script>
    
    $("#inputend").on("change", function() {
      var selectElement = document.getElementById("mi-select");
      selectElement.innerHTML = "";
    }) // O(1)
  
    $("#endpoint").on("click", function() {
      $("#mi-select").fadeIn(); // O(1)
      $("#textarea").fadeIn(); // O(1)
      $.ajax({
        type: "GET",
        url: $("#inputend").val(),
        dataType: "text",
        success: function(data) {
          var rows = data.split("\n"); // O(n), donde n es la longitud de la cadena "data"
          var columns = rows[0].split(","); // O(1) (asumiendo que el número de columnas es constante)

          var select = $("#mi-select");
          $.each(columns, function(index, column) {
            var columnValues = [];
            for (var i = 1; i < rows.length; i++) {
              var rowData = rows[i].split(","); // O(n), donde n es la longitud de la cadena "rowData"
              columnValues.push(rowData[index]);
            }

            var option = $('<option></option>').val(columnValues.join(",")).html(column); // O(n), donde n es la longitud de la cadena "columnValues"
            select.append(option);
          });
        }
      });

    }) // O(n^2)
    
$("#mi-select").on("change", function() {
  var elementos = $("#mi-select").val().split(",");  // O(n)
  var lista = [];  // O(1)
  
  for (var i = 0; i < elementos.length; i++) {  // O(n)
    var elemento = elementos[i].trim().replace('"','').replace('"','');  // O(1)
    
    if (/^\d+$/.test(elemento)) {  // O(1)
      lista.push(parseInt(elemento));  // O(1)
    }
  }
  
  $("#textarea").val(lista);  // O(n)
  
  if ($("#textarea").val() != '') {  // O(1)
    $("#sort").fadeIn();  // O(1)
  } else {
    $("#sort").fadeOut();  // O(1)
    $("#calculo").fadeOut();  // O(1)
    $("#time").fadeOut();  // O(1)
    $("#timelabel").fadeOut();  // O(1)
  }
});

$("#sort").on("change", function() {
  $("#calculo").fadeIn();  // O(1)
});

$("#calculo").on("click", function() {
  $("#time").fadeIn();  // O(1)
  $("#timelabel").fadeIn();  // O(1)
  
  if ($("#sort").val() == "1") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = bubbleSort(lista);  // O(n^2)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  } else if ($("#sort").val() == "2") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = quickSort(lista);  // O(n log n)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  } else if ($("#sort").val() == "3") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = mergeSort(lista);  // O(n log n)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  } else if ($("#sort").val() == "4") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = radixSort(lista);  // O(kn)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  } else if ($("#sort").val() == "5") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = heapSort(lista);  // O(n log n)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  } else if ($("#sort").val() == "6") {  // O(1)
    let lista = $("#textarea").val().split(",").map(function(item) {  // O(n)
      return parseInt(item.trim(), 10);  // O(1)
    });
    
    var startTime = performance.now();  // O(1)
    let sorted = countSort(lista);  // O(k + n)
    var endTime = performance.now();  // O(1)
    var executionTime = endTime - startTime;  // O(1)
    
    $("#textarea").val(sorted);  // O(n)
    $("#time").val(executionTime);  // O(1)
  }
});

function bubbleSort(arr) {
  var len = arr.length;  // O(1)
  
  for (var i = 0; i < len; i++) {  // O(n)
    for (var j = 0; j < len - 1; j++) {  // O(n)
      if (arr[j] > arr[j + 1]) {  // O(1)
        var temp = arr[j];  // O(1)
        arr[j] = arr[j + 1];  // O(1)
        arr[j + 1] = temp;  // O(1)
      }
    }
  }
  
  return arr;  // O(1)
}

function quickSort(arr) {
  if (arr.length <= 1) {  // O(1)
    return arr;  // O(1)
  }
  
  var pivot = arr[arr.length - 1];  // O(1)
  var left = [];  // O(1)
  var right = [];  // O(1)
  
  for (var i = 0; i < arr.length - 1; i++) {  // O(n)
    if (arr[i] < pivot) {  // O(1)
      left.push(arr[i]);  // O(1)
    } else {
      right.push(arr[i]);  // O(1)
    }
  }
  
  return [...quickSort(left), pivot, ...quickSort(right)];  // O(n log n)
}

function mergeSort(arr) {
  if (arr.length <= 1) {  // O(1)
    return arr;  // O(1)
  }
  
  var middle = Math.floor(arr.length / 2);  // O(1)
  var left = arr.slice(0, middle);  // O(n)
  var right = arr.slice(middle);  // O(n)
  
  return merge(mergeSort(left), mergeSort(right));  // O(n log n)
}

function merge(left, right) {
  var result = [];  // O(1)
  var i = 0;  // O(1)
  var j = 0;  // O(1)
  
  while (i < left.length && j < right.length) {  // O(n)
    if (left[i] < right[j]) {  // O(1)
      result.push(left[i]);  // O(1)
      i++;  // O(1)
    } else {
      result.push(right[j]);  // O(1)
      j++;  // O(1)
    }
  }
  
  return result.concat(left.slice(i)).concat(right.slice(j));  // O(n)
}

function radixSort(arr) {
  var max = Math.max(...arr);  // O(n)
  var maxDigits = String(max).length;  // O(1)
  var buckets = Array.from({ length: 10 }, () => []);  // O(1)
  
  for (var i = 0; i < maxDigits; i++) {  // O(k)
    for (var j = 0; j < arr.length; j++) {  // O(n)
      var digit = getDigit(arr[j], i);  // O(1)
      buckets[digit].push(arr[j]);  // O(1)
    }
    
    arr = [].concat(...buckets);  // O(n)
    buckets = Array.from({ length: 10 }, () => []);  // O(1)
  }
  
  return arr;  // O(n)
}

function getDigit(num, place) {
  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;  // O(1)
}

function heapSort(arr) {
  var len = arr.length;  // O(1)
  
  for (var i = Math.floor(len / 2) - 1; i >= 0; i--) {  // O(n)
    heapify(arr, len, i);  // O(log n)
  }
  
  for (var i = len - 1; i > 0; i--) {  // O(n)
    var temp = arr[0];  // O(1)
    arr[0] = arr[i];  // O(1)
    arr[i] = temp;  // O(1)
    
    heapify(arr, i, 0);  // O(log n)
  }
  
  return arr;  // O(1)
}

function heapify(arr, len, i) {
  var largest = i;  // O(1)
  var left = 2 * i + 1;  // O(1)
  var right = 2 * i + 2;  // O(1)
  
  if (left < len && arr[left] > arr[largest]) {  // O(1)
    largest = left;  // O(1)
  }
  
  if (right < len && arr[right] > arr[largest]) {  // O(1)
    largest = right;  // O(1)
  }
  
  if (largest !== i) {  // O(1)
    var temp = arr[i];  // O(1)
    arr[i] = arr[largest];  // O(1)
    arr[largest] = temp;  // O(1)
    
    heapify(arr, len, largest);  // O(log n)
  }
}

function countSort(arr) {
  var max = Math.max(...arr);  // O(n)
  var count = Array(max + 1).fill(0);  // O(n)
  
  for (var i = 0; i < arr.length; i++) {  // O(n)
    count[arr[i]]++;  // O(1)
  }
  
  var sorted = [];  // O(1)
  
  for (var i = 0; i < count.length; i++) {  // O(n)
    for (var j = 0; j < count[i]; j++) {  // O(n)
      sorted.push(i);  // O(1)
    }
  }
  
  return sorted;  // O(n)
}

//Bubble Sort: El peor caso de Bubble Sort es O(n^2) cuando el arreglo está ordenado en orden inverso. Por lo tanto, la complejidad de Bubble Sort es O(n^2).

//Insertion Sort: El peor caso de Insertion Sort es O(n^2) cuando el arreglo está ordenado en orden inverso. Por lo tanto, la complejidad de Insertion Sort es O(n^2).

//Selection Sort: El peor caso de Selection Sort es O(n^2) independientemente del orden de los elementos en el arreglo. Por lo tanto, la complejidad de Selection Sort es O(n^2).

//Merge Sort: El peor caso de Merge Sort es O(n log n) en todos los casos. Por lo tanto, la complejidad de Merge Sort es O(n log n).

//Radix Sort: El peor caso de Radix Sort es O(k * n), donde k es el número de dígitos máximo en los elementos del arreglo. En el peor caso, k puede ser igual a log n. Por lo tanto, la complejidad de Radix Sort es O(n log n).

//Heap Sort: El peor caso de Heap Sort es O(n log n) en todos los casos. Por lo tanto, la complejidad de Heap Sort es O(n log n).

//Count Sort: El peor caso de Count Sort es O(n + k), donde k es el rango de valores posibles en el arreglo. En el peor caso, k puede ser igual a n, lo que daría una complejidad de O(n). Sin embargo, si el rango de valores es pequeño y no depende del tamaño del arreglo, se considera O(1). Por lo tanto, la complejidad de Count Sort depende del rango de valores en el arreglo.
//Ahora para finalizar en este codigo la complejidad general sería O(n^2) 
